# Техническое задание: Прототип Electron с симуляцией данных ЭБУ (40ms)

## 1. Цель и контекст

**Цель:** Создать минимальный прототип на Electron для проверки производительности при обработке real-time данных с интервалом 40ms (25 Hz), имитирующих поток данных от ЭБУ двигателя.

**Контекст:** Перед принятием решения о возможной миграции с Qt/QML на Electron необходимо протестировать способность Electron обрабатывать непрерывный поток данных и отображать их на графиках без пропусков кадров и задержек.

**Критерий успеха:** Прототип должен стабильно работать минимум 5 минут (7500 пакетов данных) без видимых тормозов и пропусков кадров.

---

## 2. Требования

### Функциональные требования:

**FR-1: Симуляция данных ЭБУ**
- Генерация пакета данных каждые 40ms (±2ms точность)
- Пакет содержит **300 параметров двигателя** (реалистичная нагрузка)
- Данные должны быть реалистичными с плавными изменениями для критичных параметров
- Некритичные параметры могут иметь более простую генерацию

**FR-2: Передача данных UI**
- Данные передаются из Main Process в Renderer Process через IPC
- Батчинг данных для оптимизации (не каждый пакет отдельно)
- Буферизация при временных задержках UI

**FR-3: Визуализация**
- 3 графика одновременно (обороты, дроссель, AFR)
- Обновление графиков в real-time
- История: последние 500 точек на каждом графике

**FR-4: Управление симуляцией**
- Кнопка "Start" - запуск симуляции
- Кнопка "Stop" - остановка симуляции
- Отображение счетчика пакетов
- Отображение FPS (frames per second)

**FR-5: Мониторинг производительности**
- Счетчик полученных пакетов
- Счетчик отрисованных кадров
- Индикатор пропущенных пакетов (если есть)
- Время работы симуляции

### Нефункциональные требования:

**NFR-1: Производительность**
- Стабильные 60 FPS обновления UI (или близко к этому)
- Латентность данные→UI не более 50ms
- Отсутствие пропусков пакетов данных
- CPU usage не более 40% на средней машине

**NFR-2: Стабильность**
- Работа без сбоев минимум 5 минут
- Отсутствие memory leaks
- Отсутствие зависаний UI

**NFR-3: Простота**
- Минимальный код - только необходимое
- Один HTML файл для UI
- Без сложных зависимостей
- Быстрый запуск (<5 секунд)

---

## 3. Архитектура решения

### Компонентная структура:

```
┌─────────────────────────────────────────────────┐
│         Renderer Process (UI)                   │
│  ┌──────────────────────────────────────────┐  │
│  │  Control Panel                           │  │
│  │  - Start/Stop кнопки                     │  │
│  │  - Счетчики (пакеты, FPS, время)        │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │  Chart Manager                           │  │
│  │  - График RPM                            │  │
│  │  - График Throttle                       │  │
│  │  - График AFR                            │  │
│  │  - Буфер данных (500 точек)             │  │
│  └──────────────────────────────────────────┘  │
└────────────┬────────────────────────────────────┘
             │ IPC Events (ecu-data, simulation-status)
┌────────────┴────────────────────────────────────┐
│         Main Process (Node.js)                  │
│  ┌──────────────────────────────────────────┐  │
│  │  Simulation Manager                      │  │
│  │  - Start/Stop управление                 │  │
│  │  - Таймер (setInterval 40ms)            │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │  ECU Data Generator                      │  │
│  │  - Генератор реалистичных значений      │  │
│  │  - Плавные переходы между значениями    │  │
│  │  - 8 параметров двигателя               │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │  Data Batcher                            │  │
│  │  - Накопление пакетов (16ms буфер)      │  │
│  │  - Отправка батчами в UI                │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

### Поток данных:

```
1. User нажимает "Start"
   ↓
2. Renderer → IPC → Main Process ('start-simulation')
   ↓
3. Main Process запускает setInterval(40ms)
   ↓
4. Каждые 40ms: ECU Data Generator создает пакет данных
   ↓
5. Data Batcher накапливает пакеты
   ↓
6. Каждые ~16ms (60 FPS): батч отправляется в Renderer
   ↓
7. Chart Manager обновляет графики
   ↓
8. Цикл повторяется до нажатия "Stop"
```

---

## 4. Спецификации

### 4.1 Структура данных ЭБУ

**Формат пакета данных:**
```typescript
interface ECUDataPacket {
  timestamp: number;      // Unix timestamp в миллисекундах
  rpm: number;            // Обороты двигателя (800-7000 об/мин)
  throttle: number;       // Положение дроссельной заслонки (0-100%)
  afr: number;            // Air-Fuel Ratio (12.0-15.5)
  boost: number;          // Давление наддува (-0.5 до 1.5 bar)
  coolantTemp: number;    // Температура ОЖ (80-105 °C)
  fuelPressure: number;   // Давление топлива (3.0-4.5 bar)
  ignitionTiming: number; // Угол опережения зажигания (10-35 градусов)
  injectorDuration: number; // Длительность впрыска (1.5-8.0 ms)
}
```

**Пример пакета:**
```javascript
{
  timestamp: 1729353600000,
  rpm: 3500,
  throttle: 65.5,
  afr: 13.2,
  boost: 0.8,
  coolantTemp: 92,
  fuelPressure: 3.8,
  ignitionTiming: 22,
  injectorDuration: 4.2
}
```

### 4.2 IPC Events (Main ↔ Renderer)

**Renderer → Main:**
```javascript
// Запуск симуляции
channel: 'start-simulation'
payload: null

// Остановка симуляции
channel: 'stop-simulation'
payload: null
```

**Main → Renderer:**
```javascript
// Батч данных ЭБУ
channel: 'ecu-data-batch'
payload: {
  packets: ECUDataPacket[],  // Массив пакетов (обычно 2-3 пакета)
  batchSize: number          // Количество пакетов в батче
}

// Статус симуляции
channel: 'simulation-status'
payload: { 
  isRunning: boolean,
  totalPackets: number,
  uptime: number            // в секундах
}
```

### 4.3 Логика генерации данных

**Алгоритм плавных изменений:**
- Каждый параметр имеет текущее значение и направление изменения
- Изменение = (random * amplitude - amplitude/2) * direction
- При достижении границ диапазона - смена направления
- Зависимости между параметрами (например, AFR зависит от throttle)

**Реалистичные взаимосвязи:**
- При высоком throttle (>80%) → AFR стремится к 12.5 (богатая смесь)
- При низком throttle (<20%) → AFR стремится к 14.7 (стехиометрия)
- Boost появляется только при throttle > 50%
- Температура медленно растет при высоких оборотах

**Диапазоны и шаги изменений:**
```javascript
параметр          | min    | max   | step/40ms | примечание
------------------|--------|-------|-----------|------------------
rpm               | 800    | 7000  | ±50       | основной параметр
throttle          | 0      | 100   | ±5        | быстрые изменения
afr               | 12.0   | 15.5  | ±0.1      | плавно
boost             | -0.5   | 1.5   | ±0.05     | зависит от throttle
coolantTemp       | 80     | 105   | ±0.2      | медленно
fuelPressure      | 3.0    | 4.5   | ±0.05     | относительно стабильно
ignitionTiming    | 10     | 35    | ±1        | зависит от rpm
injectorDuration  | 1.5    | 8.0   | ±0.2      | зависит от throttle
```

### 4.4 Оптимизация передачи данных

**Батчинг:**
- Не отправлять каждый пакет (40ms) отдельно
- Накапливать пакеты в буфере
- Отправлять батчами каждые ~16ms (для 60 FPS)
- Типичный батч: 2-3 пакета

**Пример батча:**
```javascript
{
  packets: [
    { timestamp: 1000, rpm: 3500, ... },  // пакет 1 (0ms)
    { timestamp: 1040, rpm: 3550, ... },  // пакет 2 (40ms)
    { timestamp: 1080, rpm: 3600, ... }   // пакет 3 (80ms)
  ],
  batchSize: 3
}
```

**Буферизация:**
- Если UI тормозит - пакеты накапливаются в буфере
- Максимальный размер буфера: 50 пакетов (2 секунды)
- При переполнении - удалять старые пакеты (FIFO)

### 4.5 Библиотека для графиков

**Рекомендация: Chart.js v4+ с streaming plugin**

**Причины выбора:**
- Легковесная (под 200KB минимизированная)
- Отличная производительность для real-time данных
- Streaming plugin из коробки
- Простое API

**Конфигурация графика:**
```javascript
{
  type: 'line',
  options: {
    animation: false,              // КРИТИЧНО: отключить анимации
    parsing: false,                // Отключить парсинг для скорости
    normalized: true,              // Данные уже нормализованы
    scales: {
      x: {
        type: 'realtime',          // streaming plugin
        realtime: {
          duration: 20000,         // 20 секунд истории
          refresh: 16,             // обновление каждые 16ms (60 FPS)
          delay: 0                 // без задержки
        }
      }
    },
    elements: {
      line: {
        borderWidth: 2,
        tension: 0.1               // небольшое скругление
      },
      point: {
        radius: 0                  // не рисовать точки (производительность)
      }
    }
  }
}
```

---

## 5. Критерии выполнения

### Обязательные критерии (must have):

✅ **KPI-1:** Симуляция работает стабильно 5+ минут без сбоев

✅ **KPI-2:** FPS не падает ниже 50 (целевой 60 FPS)

✅ **KPI-3:** Отсутствуют пропуски пакетов данных (все 7500+ пакетов обработаны)

✅ **KPI-4:** Латентность данные→отображение не более 50ms

✅ **KPI-5:** CPU usage не более 40% на тестовой машине

✅ **KPI-6:** Память не растет более чем на 50MB за 5 минут работы

✅ **KPI-7:** Три графика обновляются синхронно и плавно

### Желательные критерии (nice to have):

⭐ **KPI-8:** FPS стабильно держится на 60

⭐ **KPI-9:** Возможность работы 15+ минут без деградации

⭐ **KPI-10:** CPU usage не более 30%

### Критерии провала (fail criteria):

❌ **FAIL-1:** Заметные подвисания UI (freeze >100ms)

❌ **FAIL-2:** Пропуск более 1% пакетов данных

❌ **FAIL-3:** Memory leak (рост памяти >200MB за 5 минут)

❌ **FAIL-4:** Crash приложения

---

## 6. Технический стек

### Основные технологии:

**Runtime:**
- Electron 27+ (последняя стабильная версия)
- Node.js 18+ (встроен в Electron)

**UI:**
- Vanilla JavaScript (без фреймворков для простоты)
- HTML5 + CSS3
- Chart.js 4.x + chartjs-plugin-streaming

**Опционально (если нужна типизация):**
- TypeScript (можно, но не обязательно для прототипа)

### Зависимости:

```json
{
  "dependencies": {
    "electron": "^27.0.0",
    "chart.js": "^4.4.0",
    "chartjs-plugin-streaming": "^2.0.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0"  // опционально
  }
}
```

---

## 7. Структура проекта

```
ecu-tuner-electron/
├── package.json                 # Конфигурация проекта
├── main.js                      # Main Process (Node.js)
├── preload.js                   # Preload script (мост IPC)
├── index.html                   # UI разметка
├── renderer.js                  # Renderer Process логика
├── styles.css                   # Стили (опционально)
└── README.md                    # Инструкция запуска
```

### Описание файлов:

**main.js** (200-300 строк)
- Создание BrowserWindow
- ECU Data Generator класс
- Simulation Manager
- Data Batcher
- IPC handlers

**preload.js** (20-30 строк)
- Expose безопасного IPC API в window объект
- contextBridge.exposeInMainWorld

**index.html** (100-150 строк)
- Разметка интерфейса
- 3 canvas элемента для графиков
- Control panel (кнопки, счетчики)
- Подключение Chart.js из CDN

**renderer.js** (150-200 строк)
- Инициализация 3 графиков Chart.js
- IPC event listeners
- Обновление счетчиков
- FPS калькулятор

---

## 8. Зависимости и ограничения

### Технические ограничения:

**ОГРАН-1:** Используется Vanilla JS, не React/Vue (для простоты прототипа)

**ОГРАН-2:** Графики только Chart.js (не Plotly, не D3.js)

**ОГРАН-3:** Без сохранения данных (только in-memory)

**ОГРАН-4:** Без работы с реальным COM-портом (только симуляция)

**ОГРАН-5:** Один экран (без роутинга, без множественных окон)

### Внешние зависимости:

**ЗАВ-1:** Chart.js + streaming plugin (можно загрузить с CDN)

**ЗАВ-2:** Electron runtime

**ЗАВ-3:** Нет - все остальное нативно

### Ограничения окружения:

**ОКР-1:** Тестирование на Windows 10/11 (основная платформа)

**ОКР-2:** Минимальные требования: 4GB RAM, dual-core CPU

**ОКР-3:** Не требуется интернет после установки зависимостей

---

## 9. Метрики и тестирование

### Метрики производительности (встроенные в UI):

**Метрика 1: Packet Counter**
- Счетчик всех полученных пакетов
- Обновление в real-time
- Формат: "Packets: 7542"

**Метрика 2: FPS Counter**
- Кадры в секунду отрисовки графиков
- Расчет за последнюю секунду
- Формат: "FPS: 58"
- Цветовая индикация:
  - Зеленый: ≥55 FPS
  - Желтый: 45-54 FPS
  - Красный: <45 FPS

**Метрика 3: Uptime**
- Время работы симуляции
- Формат: "Uptime: 5m 23s"

**Метрика 4: Dropped Packets (опционально)**
- Количество пропущенных пакетов
- Расчет: ожидаемые пакеты - полученные пакеты
- Формат: "Dropped: 12 (0.16%)"

### Сценарии тестирования:

**ТЕСТ-1: Короткий прогон (1 минута)**
- Запуск симуляции на 1 минуту
- Проверка стабильности FPS
- Проверка отсутствия визуальных глюков

**ТЕСТ-2: Средний прогон (5 минут)**
- Запуск симуляции на 5 минут
- Мониторинг CPU usage
- Проверка отсутствия memory leak
- Основной acceptance test

**ТЕСТ-3: Долгий прогон (15 минут)**
- Стресс-тест
- Проверка деградации производительности
- Опционально

**ТЕСТ-4: Start/Stop циклы**
- 10 циклов запуск→работа 30с→остановка
- Проверка корректности очистки ресурсов
- Проверка отсутствия утечек при перезапуске

### Инструменты измерения:

**Встроенные в прототип:**
- FPS counter (рендерер считает сам)
- Packet counter (main process)
- Performance.now() для латентности

**Chrome DevTools:**
- Performance profiler
- Memory profiler
- Task Manager (CPU, Memory)

**Внешние (опционально):**
- Process Explorer (Windows)
- Activity Monitor (macOS)

---

## 10. План реализации (roadmap для Claude Code)

### Этап 1: Базовая структура (30 минут)
- Создать структуру проекта
- Настроить package.json
- Создать пустые main.js, preload.js, index.html, renderer.js
- Запустить пустое Electron окно

### Этап 2: Симуляция данных (45 минут)
- Реализовать ECU Data Generator класс
- Реализовать Simulation Manager (start/stop)
- Реализовать Data Batcher
- Тестовый вывод в console.log

### Этап 3: IPC коммуникация (30 минут)
- Настроить preload.js с contextBridge
- Реализовать IPC handlers в main.js
- Реализовать IPC listeners в renderer.js
- Проверить передачу данных

### Этап 4: UI - Control Panel (30 минут)
- Создать разметку кнопок и счетчиков
- Подключить обработчики Start/Stop
- Реализовать обновление счетчиков
- Базовые стили

### Этап 5: Графики Chart.js (60 минут)
- Подключить Chart.js + streaming plugin
- Создать 3 графика (RPM, Throttle, AFR)
- Настроить real-time режим
- Подключить к потоку данных

### Этап 6: Метрики производительности (30 минут)
- Реализовать FPS counter
- Реализовать uptime timer
- Добавить цветовую индикацию FPS
- Опционально: dropped packets

### Этап 7: Тестирование и доработка (45 минут)
- Прогнать все тестовые сценарии
- Исправить найденные баги
- Оптимизация узких мест
- Финальная проверка

**Общее время: ~4 часа разработки**

---

## 11. Пример использования (User Flow)

### Сценарий 1: Первый запуск

```
1. Пользователь запускает `npm start`
   → Открывается окно приложения
   → Видит 3 пустых графика и кнопку "Start Simulation"

2. Пользователь нажимает "Start Simulation"
   → Кнопка меняется на "Stop Simulation"
   → Графики начинают заполняться данными
   → Счетчики начинают расти (Packets, Uptime)
   → FPS показывает ~60 (зеленый цвет)

3. Пользователь наблюдает за графиками 5 минут
   → Графики плавно обновляются
   → RPM колеблется в диапазоне 800-7000
   → Throttle меняется 0-100%
   → AFR реагирует на throttle (12-15.5)
   → FPS стабилен на 58-60
   → Packet counter показывает ~7500 пакетов

4. Пользователь нажимает "Stop Simulation"
   → Симуляция останавливается
   → Графики перестают обновляться
   → Счетчики замораживаются
   → Кнопка меняется обратно на "Start Simulation"

5. Пользователь проверяет DevTools
   → Memory: ~200MB (стабильно)
   → CPU: 25-35% (приемлемо)
   → No errors in console
   → Вывод: Electron справляется! ✅
```

### Сценарий 2: Стресс-тест

```
1. Запустить симуляцию на 15 минут
2. Открыть Task Manager
3. Мониторить CPU, Memory, FPS
4. Результат:
   - Если FPS стабилен >50 весь период → PASS ✅
   - Если Memory растет <50MB → PASS ✅
   - Если CPU <40% → PASS ✅
   - Иначе → требуется оптимизация ⚠️
```

---

## 12. Ожидаемый результат

После реализации этого ТЗ мы получим:

✅ **Рабочий прототип** на Electron с симуляцией real-time данных

✅ **Объективные метрики** производительности для принятия решения

✅ **Понимание** узких мест Electron для данной задачи

✅ **Базу кода** для дальнейшего развития (если решим мигрировать)

✅ **Сравнительные данные** с Qt-решением

### Следующие шаги после прототипа:

**Если результаты хорошие (FPS >55, CPU <35%):**
- Принять решение о миграции на Electron
- Разработать полное ТЗ для production приложения
- Начать постепенную миграцию компонентов

**Если результаты средние (FPS 45-55, CPU 35-45%):**
- Провести оптимизацию прототипа
- Протестировать альтернативные библиотеки графиков
- Повторное тестирование

**Если результаты плохие (FPS <45, CPU >45%):**
- Остаться на Qt/QML
- Задокументировать причины
- Рассмотреть гибридный подход

---

## 13. Контакты и вопросы

**Реализация:** Claude Code (терминал)

**Roadmap:** На основе этого ТЗ

**Примерное время разработки:** 4 часа

**Вопросы для уточнения перед началом:**
1. Какая версия Electron предпочтительна?
2. Нужна ли TypeScript типизация или достаточно JS?
3. Требуется ли сохранение логов производительности в файл?
4. Какие дополнительные параметры ЭБУ включить в симуляцию?

---

**Версия ТЗ:** 1.0  
**Дата:** 19 октября 2025  
**Статус:** Готово к реализации